package main

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"

	"github.com/atombender/go-jsonschema/pkg/generator"
)

const (
	schemaBundleFile    = "codex_app_server_protocol.schemas.json"
	generatedHeaderBase = "// DO NOT EDIT.\n// Generated by internal/codegen.\n"
	codexRepoRootEnv    = "CODEX_REPO_ROOT"
)

func main() {
	sdkRoot, err := repoRoot()
	if err != nil {
		fatal(err)
	}
	codexRoot, err := codexRepoRoot(sdkRoot)
	if err != nil {
		fatal(err)
	}
	codexCommit, err := codexCommitHash(codexRoot)
	if err != nil {
		fatal(err)
	}

	tempDir := filepath.Join(os.TempDir(), "codex-schema-go-sdk")
	if err := os.RemoveAll(tempDir); err != nil {
		fatal(err)
	}
	if err := os.MkdirAll(tempDir, 0o755); err != nil {
		fatal(err)
	}
	defer func() {
		_ = os.RemoveAll(tempDir)
	}()

	if err := exportSchemas(codexRoot, tempDir); err != nil {
		fatal(err)
	}
	if err := generateProtocolTypes(tempDir, sdkRoot, codexCommit); err != nil {
		fatal(err)
	}

	if err := generateRPCStubs(tempDir, sdkRoot, codexCommit); err != nil {
		fatal(err)
	}
}

func exportSchemas(codexRoot, outDir string) error {
	cmd := exec.Command("cargo", "run", "-p", "codex-app-server-protocol", "--bin", "export", "--", "--out", outDir)
	cmd.Dir = filepath.Join(codexRoot, "codex-rs")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}

func generateProtocolTypes(schemaDir, repoRoot, codexCommit string) error {
	cfg := generator.Config{
		DefaultPackageName: "protocol",
		DefaultOutputName:  "types_gen.go",
		Tags:               []string{"json"},
		Capitalizations:    []string{"ID", "JSON", "RPC", "MCP", "HTTP", "URL", "SSE", "UUID"},
		OnlyModels:         true,
	}
	gen, err := generator.New(cfg)
	if err != nil {
		return err
	}

	schemaFiles, err := findSchemaFiles(schemaDir)
	if err != nil {
		return err
	}

	skip := skipSchemaFiles()
	var fallbacks []string
	var titles []string
	for _, file := range schemaFiles {
		if filepath.Base(file) == schemaBundleFile {
			continue
		}
		if skip[filepath.Base(file)] {
			continue
		}
		title, titleErr := schemaTitle(file)
		if titleErr != nil {
			return titleErr
		}
		if title != "" {
			titles = append(titles, title)
		}
		if err := safeDoFile(gen, file); err != nil {
			if title == "" {
				return fmt.Errorf("generate types from %s: %w", file, err)
			}
			fallbacks = append(fallbacks, title)
		}
	}

	sources, err := gen.Sources()
	if err != nil {
		return err
	}

	outDir := filepath.Join(repoRoot, "protocol")
	if err := os.MkdirAll(outDir, 0o755); err != nil {
		return err
	}

	generated := collectGeneratedTypes(sources)
	for name := range manualProtocolTypes() {
		generated[name] = struct{}{}
	}
	for _, title := range titles {
		if title == "" {
			continue
		}
		if _, ok := generated[title]; ok {
			continue
		}
		if _, ok := generated[title+"JSON"]; ok {
			continue
		}
		fallbacks = append(fallbacks, title)
	}

	for name, src := range sources {
		normalized := normalizeGeneratedHeader(src, codexCommit)
		if err := os.WriteFile(filepath.Join(outDir, name), normalized, 0o644); err != nil {
			return err
		}
	}

	if err := writeFallbackTypes(outDir, fallbacks, generated, codexCommit); err != nil {
		return err
	}

	if err := writeProtocolAliases(outDir, generated, fallbacks, codexCommit); err != nil {
		return err
	}

	return nil
}

type schemaDoc struct {
	Definitions map[string]json.RawMessage `json:"definitions"`
}

type schemaVariant struct {
	Properties map[string]schemaProperty `json:"properties"`
}

type schemaProperty struct {
	Enum  []string `json:"enum"`
	Ref   string   `json:"$ref"`
	Type  string   `json:"type"`
	Items *struct {
		Ref string `json:"$ref"`
	} `json:"items"`
}

type oneOfSchema struct {
	OneOf []schemaVariant `json:"oneOf"`
}

func generateRPCStubs(schemaDir, repoRoot, codexCommit string) error {
	defs, err := parseDefinitionNames(schemaDir)
	if err != nil {
		return err
	}

	clientMethods, err := loadMethods(filepath.Join(schemaDir, "ClientRequest.json"))
	if err != nil {
		return err
	}

	serverMethods, err := loadMethods(filepath.Join(schemaDir, "ServerRequest.json"))
	if err != nil {
		return err
	}

	notifications, err := loadNotifications(filepath.Join(schemaDir, "ServerNotification.json"))
	if err != nil {
		return err
	}

	clientRPC, err := buildRPCMethods(clientMethods, defs, clientResponseOverrides())
	if err != nil {
		return err
	}

	serverRPC, err := buildRPCMethods(serverMethods, defs, nil)
	if err != nil {
		return err
	}

	outDir := filepath.Join(repoRoot, "rpc")
	if err := os.MkdirAll(outDir, 0o755); err != nil {
		return err
	}

	if err := writeFile(outDir, "client_requests_gen.go", renderClientRequests(clientRPC, codexCommit)); err != nil {
		return err
	}

	if err := writeFile(outDir, "server_requests_gen.go", renderServerRequests(serverRPC, codexCommit)); err != nil {
		return err
	}

	if err := writeFile(outDir, "notifications_gen.go", renderNotifications(notifications, codexCommit)); err != nil {
		return err
	}

	return nil
}

func parseDefinitionNames(schemaDir string) (map[string]struct{}, error) {
	files, err := findSchemaFiles(schemaDir)
	if err != nil {
		return nil, err
	}
	defs := make(map[string]struct{})
	for _, file := range files {
		data, err := os.ReadFile(file)
		if err != nil {
			return nil, err
		}
		var doc struct {
			Title       string                     `json:"title"`
			Definitions map[string]json.RawMessage `json:"definitions"`
		}
		if err := json.Unmarshal(data, &doc); err != nil {
			return nil, err
		}
		if doc.Title != "" {
			defs[doc.Title] = struct{}{}
		}
		for name := range doc.Definitions {
			defs[name] = struct{}{}
		}
	}
	return defs, nil
}

func schemaTitle(path string) (string, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}
	var doc struct {
		Title string `json:"title"`
	}
	if err := json.Unmarshal(data, &doc); err != nil {
		return "", err
	}
	return doc.Title, nil
}

func writeFallbackTypes(outDir string, titles []string, generated map[string]struct{}, codexCommit string) error {
	fallbackPath := filepath.Join(outDir, "fallback_gen.go")
	if len(titles) == 0 {
		_ = os.Remove(fallbackPath)
		return nil
	}

	unique := map[string]struct{}{}
	for _, title := range titles {
		if title != "" {
			unique[title] = struct{}{}
		}
	}

	names := make([]string, 0, len(unique))
	for name := range unique {
		if _, exists := generated[name]; !exists {
			names = append(names, name)
		}
	}
	if len(names) == 0 {
		_ = os.Remove(fallbackPath)
		return nil
	}
	sort.Strings(names)

	var b strings.Builder
	b.WriteString(generatedHeader(codexCommit))
	b.WriteString("package protocol\n\n")
	b.WriteString("// Fallback types for schemas that failed to generate.\n")
	for _, name := range names {
		b.WriteString("type ")
		b.WriteString(name)
		b.WriteString(" interface{}\n")
	}

	return os.WriteFile(fallbackPath, []byte(b.String()), 0o644)
}

func collectGeneratedTypes(sources map[string][]byte) map[string]struct{} {
	generated := map[string]struct{}{}
	for _, src := range sources {
		lines := strings.Split(string(src), "\n")
		for _, line := range lines {
			line = strings.TrimSpace(line)
			if strings.HasPrefix(line, "type ") {
				fields := strings.Fields(line)
				if len(fields) >= 2 {
					generated[fields[1]] = struct{}{}
				}
			}
		}
	}
	return generated
}

func writeProtocolAliases(outDir string, generated map[string]struct{}, fallbacks []string, codexCommit string) error {
	existing := map[string]struct{}{}
	for name := range generated {
		existing[name] = struct{}{}
	}
	for _, name := range fallbacks {
		if name != "" {
			existing[name] = struct{}{}
		}
	}

	aliases := map[string]string{}
	for name := range generated {
		if !strings.HasSuffix(name, "JSON") {
			continue
		}
		base := strings.TrimSuffix(name, "JSON")
		if base == "" {
			continue
		}
		if _, ok := existing[base]; ok {
			continue
		}
		aliases[base] = name
	}

	aliasPath := filepath.Join(outDir, "aliases_gen.go")
	if len(aliases) == 0 {
		_ = os.Remove(aliasPath)
		return nil
	}

	names := make([]string, 0, len(aliases))
	for name := range aliases {
		names = append(names, name)
	}
	sort.Strings(names)

	var b strings.Builder
	b.WriteString(generatedHeader(codexCommit))
	b.WriteString("package protocol\n\n")
	b.WriteString("// Aliases for JSON-suffixed schema types.\n")
	for _, name := range names {
		b.WriteString("type ")
		b.WriteString(name)
		b.WriteString(" = ")
		b.WriteString(aliases[name])
		b.WriteString("\n")
	}

	return os.WriteFile(aliasPath, []byte(b.String()), 0o644)
}

func skipSchemaFiles() map[string]bool {
	return map[string]bool{
		"JSONRPCMessage.json":      true,
		"JSONRPCRequest.json":      true,
		"JSONRPCResponse.json":     true,
		"JSONRPCNotification.json": true,
		"JSONRPCError.json":        true,
		"JSONRPCErrorError.json":   true,
		"EventMsg.json":            true,
		"RequestId.json":           true,
	}
}

func loadMethods(path string) ([]rpcMethod, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	var doc oneOfSchema
	if err := json.Unmarshal(data, &doc); err != nil {
		return nil, err
	}

	methods := make([]rpcMethod, 0, len(doc.OneOf))
	for _, variant := range doc.OneOf {
		method := ""
		if prop, ok := variant.Properties["method"]; ok && len(prop.Enum) == 1 {
			method = prop.Enum[0]
		}
		if method == "" {
			continue
		}

		paramsType := ""
		if prop, ok := variant.Properties["params"]; ok {
			if prop.Ref != "" {
				paramsType = refName(prop.Ref)
			} else if prop.Type == "null" {
				paramsType = ""
			}
		}

		methods = append(methods, rpcMethod{
			Method:     method,
			ParamsType: paramsType,
		})
	}

	sort.Slice(methods, func(i, j int) bool { return methods[i].Method < methods[j].Method })

	return methods, nil
}

func loadNotifications(path string) ([]rpcNotification, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	var doc oneOfSchema
	if err := json.Unmarshal(data, &doc); err != nil {
		return nil, err
	}

	notifications := make([]rpcNotification, 0, len(doc.OneOf))
	for _, variant := range doc.OneOf {
		method := ""
		if prop, ok := variant.Properties["method"]; ok && len(prop.Enum) == 1 {
			method = prop.Enum[0]
		}
		if method == "" {
			continue
		}

		paramsType := ""
		if prop, ok := variant.Properties["params"]; ok {
			if prop.Ref != "" {
				paramsType = refName(prop.Ref)
			} else if prop.Type == "null" {
				paramsType = ""
			}
		}

		notifications = append(notifications, rpcNotification{
			Method:     method,
			ParamsType: paramsType,
		})
	}

	sort.Slice(notifications, func(i, j int) bool { return notifications[i].Method < notifications[j].Method })

	return notifications, nil
}

func refName(ref string) string {
	const prefix = "#/definitions/"
	if strings.HasPrefix(ref, prefix) {
		return strings.TrimPrefix(ref, prefix)
	}
	return ref
}

type rpcMethod struct {
	Method       string
	ParamsType   string
	ResponseType string
}

type rpcNotification struct {
	Method     string
	ParamsType string
}

func buildRPCMethods(methods []rpcMethod, defs map[string]struct{}, overrides map[string]string) ([]rpcMethod, error) {
	resolved := make([]rpcMethod, 0, len(methods))
	for _, method := range methods {
		responseType, err := resolveResponseType(method, defs, overrides)
		if err != nil {
			return nil, err
		}
		method.ResponseType = responseType
		resolved = append(resolved, method)
	}
	return resolved, nil
}

func resolveResponseType(method rpcMethod, defs map[string]struct{}, overrides map[string]string) (string, error) {
	if overrides != nil {
		if override, ok := overrides[method.Method]; ok {
			return override, nil
		}
	}

	if method.ParamsType != "" {
		base := strings.TrimSuffix(method.ParamsType, "Params")
		candidate := base + "Response"
		if _, ok := defs[candidate]; ok {
			return candidate, nil
		}
	}

	candidate := methodBaseName(method.Method) + "Response"
	if _, ok := defs[candidate]; ok {
		return candidate, nil
	}

	return "", fmt.Errorf("unable to resolve response type for method %q", method.Method)
}

func methodBaseName(method string) string {
	parts := strings.FieldsFunc(method, func(r rune) bool {
		return !(r >= 'a' && r <= 'z' || r >= 'A' && r <= 'Z' || r >= '0' && r <= '9')
	})
	var b strings.Builder
	for _, part := range parts {
		if part == "" {
			continue
		}
		b.WriteString(strings.ToUpper(part[:1]))
		if len(part) > 1 {
			b.WriteString(part[1:])
		}
	}
	return b.String()
}

func clientResponseOverrides() map[string]string {
	return map[string]string{
		"account/logout":             "LogoutAccountResponse",
		"account/rateLimits/read":    "GetAccountRateLimitsResponse",
		"addConversationListener":    "AddConversationSubscriptionResponse",
		"config/value/write":         "ConfigWriteResponse",
		"config/batchWrite":          "ConfigWriteResponse",
		"config/mcpServer/reload":    "McpServerRefreshResponse",
		"removeConversationListener": "RemoveConversationSubscriptionResponse",
	}
}

func renderClientRequests(methods []rpcMethod, codexCommit string) []byte {
	var b strings.Builder
	b.WriteString(generatedHeader(codexCommit))
	b.WriteString("package rpc\n\n")
	b.WriteString("import (\n\t\"context\"\n\t\"encoding/json\"\n\n\t\"github.com/pmenglund/codex-sdk-go/protocol\"\n)\n\n")

	b.WriteString("// ClientRequests exposes typed JSON-RPC calls supported by the app-server.\n")
	b.WriteString("type ClientRequests interface {\n")
	for _, method := range methods {
		if method.ParamsType == "" {
			b.WriteString(fmt.Sprintf("\t%s(ctx context.Context) (*protocol.%s, error)\n", methodName(method.Method), method.ResponseType))
		} else {
			b.WriteString(fmt.Sprintf("\t%s(ctx context.Context, params %s) (*protocol.%s, error)\n", methodName(method.Method), paramsType(method.ParamsType), method.ResponseType))
		}
	}
	b.WriteString("}\n\n")

	b.WriteString("// Client implements ClientRequests using JSON-RPC.\n")
	for _, method := range methods {
		if method.ParamsType == "" {
			b.WriteString(fmt.Sprintf("func (c *Client) %s(ctx context.Context) (*protocol.%s, error) {\n", methodName(method.Method), method.ResponseType))
		} else {
			b.WriteString(fmt.Sprintf("func (c *Client) %s(ctx context.Context, params %s) (*protocol.%s, error) {\n", methodName(method.Method), paramsType(method.ParamsType), method.ResponseType))
		}
		b.WriteString("\tvar result protocol.")
		b.WriteString(method.ResponseType)
		b.WriteString("\n")
		if method.ParamsType == "" {
			b.WriteString(fmt.Sprintf("\tif err := c.Call(ctx, %q, nil, &result); err != nil {\n", method.Method))
		} else {
			b.WriteString(fmt.Sprintf("\tif err := c.Call(ctx, %q, params, &result); err != nil {\n", method.Method))
		}
		b.WriteString("\t\treturn nil, err\n\t}\n\treturn &result, nil\n}\n\n")
	}

	b.WriteString("// BuildClientRequest builds a JSON-RPC request for a client method.\n")
	b.WriteString("func BuildClientRequest(method string, params any, id RequestID) (JSONRPCRequest, error) {\n")
	b.WriteString("\tvar raw json.RawMessage\n\tif params != nil {\n\t\tdata, err := json.Marshal(params)\n\t\tif err != nil {\n\t\t\treturn JSONRPCRequest{}, err\n\t\t}\n\t\traw = data\n\t}\n\treturn JSONRPCRequest{ID: id, Method: method, Params: raw}, nil\n}\n")

	return []byte(b.String())
}

func renderServerRequests(methods []rpcMethod, codexCommit string) []byte {
	var b strings.Builder
	b.WriteString(generatedHeader(codexCommit))
	b.WriteString("package rpc\n\n")
	b.WriteString("import (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"github.com/pmenglund/codex-sdk-go/protocol\"\n)\n\n")

	b.WriteString("// ServerRequestHandler handles requests initiated by the app-server.\n")
	b.WriteString("type ServerRequestHandler interface {\n")
	for _, method := range methods {
		if method.ParamsType == "" {
			b.WriteString(fmt.Sprintf("\t%s(ctx context.Context) (*protocol.%s, error)\n", methodName(method.Method), method.ResponseType))
		} else {
			b.WriteString(fmt.Sprintf("\t%s(ctx context.Context, params %s) (*protocol.%s, error)\n", methodName(method.Method), paramsType(method.ParamsType), method.ResponseType))
		}
	}
	b.WriteString("}\n\n")

	b.WriteString("func dispatchServerRequest(ctx context.Context, handler ServerRequestHandler, req JSONRPCRequest) (any, error) {\n")
	b.WriteString("\tswitch req.Method {\n")
	for _, method := range methods {
		b.WriteString(fmt.Sprintf("\tcase %q:\n", method.Method))
		if method.ParamsType == "" {
			b.WriteString("\t\treturn handler.")
			b.WriteString(methodName(method.Method))
			b.WriteString("(ctx)\n")
		} else {
			b.WriteString("\t\tvar params protocol.")
			b.WriteString(method.ParamsType)
			b.WriteString("\n")
			b.WriteString("\t\tif len(req.Params) > 0 {\n\t\t\tif err := json.Unmarshal(req.Params, &params); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n")
			b.WriteString("\t\treturn handler.")
			b.WriteString(methodName(method.Method))
			b.WriteString("(ctx, params)\n")
		}
	}
	b.WriteString("\tdefault:\n\t\treturn nil, fmt.Errorf(\"unsupported server request %q\", req.Method)\n\t}\n}\n")

	return []byte(b.String())
}

func renderNotifications(notifications []rpcNotification, codexCommit string) []byte {
	var b strings.Builder
	b.WriteString(generatedHeader(codexCommit))
	b.WriteString("package rpc\n\n")
	b.WriteString("import (\n\t\"encoding/json\"\n\n\t\"github.com/pmenglund/codex-sdk-go/protocol\"\n)\n\n")

	b.WriteString("// Notification represents a typed server notification.\n")
	b.WriteString("type Notification struct {\n\tMethod string\n\tParams any\n\tRaw json.RawMessage\n}\n\n")

	b.WriteString("type notificationParser func(json.RawMessage) (Notification, error)\n\n")
	b.WriteString("var notificationParsers = map[string]notificationParser{\n")
	for _, notification := range notifications {
		b.WriteString(fmt.Sprintf("\t%q: func(params json.RawMessage) (Notification, error) {\n", notification.Method))
		if notification.ParamsType == "" {
			b.WriteString(fmt.Sprintf("\t\treturn Notification{Method: %q, Params: nil, Raw: params}, nil\n", notification.Method))
		} else {
			b.WriteString("\t\tvar payload protocol.")
			b.WriteString(notification.ParamsType)
			b.WriteString("\n")
			b.WriteString("\t\tif len(params) > 0 {\n\t\t\tif err := json.Unmarshal(params, &payload); err != nil {\n\t\t\t\treturn Notification{Method: ")
			b.WriteString(fmt.Sprintf("%q", notification.Method))
			b.WriteString(", Raw: params}, err\n\t\t\t}\n\t\t}\n")
			b.WriteString("\t\treturn Notification{Method: ")
			b.WriteString(fmt.Sprintf("%q", notification.Method))
			b.WriteString(", Params: payload, Raw: params}, nil\n")
		}
		b.WriteString("\t},\n")
	}
	b.WriteString("}\n\n")

	b.WriteString("func parseServerNotification(method string, params json.RawMessage) (Notification, error) {\n")
	b.WriteString("\tif handler, ok := notificationParsers[method]; ok {\n\t\treturn handler(params)\n\t}\n")
	b.WriteString("\treturn Notification{Method: method, Raw: params}, nil\n}\n")

	return []byte(b.String())
}

func paramsType(name string) string {
	if name == "" {
		return "struct{}"
	}
	return "protocol." + name
}

func manualProtocolTypes() map[string]struct{} {
	return map[string]struct{}{
		"ErrorNotification":         {},
		"ItemCompletedNotification": {},
		"ThreadResumeResponse":      {},
		"ThreadStartResponse":       {},
		"TurnCompletedNotification": {},
		"TurnStartedNotification":   {},
	}
}

func methodName(method string) string {
	base := methodBaseName(method)
	if base == "" {
		return "Unknown"
	}
	return base
}

func normalizeGeneratedHeader(src []byte, codexCommit string) []byte {
	if len(src) == 0 {
		return src
	}
	parts := strings.SplitN(string(src), "\n", 2)
	if len(parts) == 0 {
		return src
	}
	header := strings.TrimSpace(parts[0])
	headerLower := strings.ToLower(header)
	if !strings.HasPrefix(headerLower, "// code generated") && !strings.HasPrefix(headerLower, "// generated") {
		return src
	}
	rest := ""
	if len(parts) > 1 {
		rest = strings.TrimLeft(parts[1], "\n")
	}
	return []byte(generatedHeader(codexCommit) + rest)
}

func generatedHeader(codexCommit string) string {
	return generatedHeaderBase + "// Source codex commit: " + codexCommit + "\n\n"
}

func writeFile(dir, name string, contents []byte) error {
	path := filepath.Join(dir, name)
	return os.WriteFile(path, contents, 0o644)
}

func findSchemaFiles(schemaDir string) ([]string, error) {
	var files []string
	err := filepath.WalkDir(schemaDir, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}
		if filepath.Ext(path) != ".json" {
			return nil
		}
		files = append(files, path)
		return nil
	})
	if err != nil {
		return nil, err
	}
	sort.Strings(files)
	return files, nil
}

func safeDoFile(gen *generator.Generator, file string) (err error) {
	sanitized, cleanup, err := sanitizeSchemaFile(file)
	if err != nil {
		return err
	}
	defer cleanup()
	defer func() {
		if r := recover(); r != nil {
			err = fmt.Errorf("panic: %v", r)
		}
	}()
	return gen.DoFile(sanitized)
}

func sanitizeSchemaFile(path string) (string, func(), error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return "", nil, err
	}
	var node any
	if err := json.Unmarshal(data, &node); err != nil {
		return "", nil, err
	}
	stripSubschemas(node)
	out, err := json.Marshal(node)
	if err != nil {
		return "", nil, err
	}
	sanitizedName := "sanitized-" + filepath.Base(path)
	sanitizedPath := filepath.Join(filepath.Dir(path), sanitizedName)
	if err := os.WriteFile(sanitizedPath, out, 0o644); err != nil {
		return "", nil, err
	}
	cleanup := func() {
		_ = os.Remove(sanitizedPath)
	}
	return sanitizedPath, cleanup, nil
}

func stripSubschemas(node any) {
	switch value := node.(type) {
	case map[string]any:
		delete(value, "oneOf")
		delete(value, "anyOf")
		for _, child := range value {
			stripSubschemas(child)
		}
	case []any:
		for _, child := range value {
			stripSubschemas(child)
		}
	}
}

func repoRoot() (string, error) {
	cwd, err := os.Getwd()
	if err != nil {
		return "", err
	}

	// Walk up until we find this repository root.
	current := cwd
	for {
		if exists(filepath.Join(current, "go.mod")) && exists(filepath.Join(current, "internal", "codegen", "main.go")) {
			return current, nil
		}
		parent := filepath.Dir(current)
		if parent == current {
			break
		}
		current = parent
	}

	return "", fmt.Errorf("unable to locate codex-sdk-go repo root from %s", cwd)
}

func codexRepoRoot(sdkRoot string) (string, error) {
	if configured := strings.TrimSpace(os.Getenv(codexRepoRootEnv)); configured != "" {
		root := configured
		if !filepath.IsAbs(root) {
			root = filepath.Join(sdkRoot, root)
		}
		if !exists(filepath.Join(root, "codex-rs")) {
			return "", fmt.Errorf("%s=%q does not contain codex-rs", codexRepoRootEnv, configured)
		}
		return root, nil
	}

	defaultRoot := filepath.Join(sdkRoot, "..", "codex")
	if exists(filepath.Join(defaultRoot, "codex-rs")) {
		return defaultRoot, nil
	}

	return "", fmt.Errorf("could not find codex checkout at %s (set %s)", defaultRoot, codexRepoRootEnv)
}

func codexCommitHash(codexRoot string) (string, error) {
	cmd := exec.Command("git", "-C", codexRoot, "rev-parse", "HEAD")
	out, err := cmd.CombinedOutput()
	if err != nil {
		msg := strings.TrimSpace(string(out))
		if msg == "" {
			return "", fmt.Errorf("resolve codex commit hash: %w", err)
		}
		return "", fmt.Errorf("resolve codex commit hash: %s", msg)
	}
	hash := strings.TrimSpace(string(out))
	if hash == "" {
		return "", fmt.Errorf("resolve codex commit hash: empty hash")
	}
	return hash, nil
}

func exists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

func fatal(err error) {
	fmt.Fprintln(os.Stderr, err)
	os.Exit(1)
}
