package main

import (
	"encoding/json"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/atombender/go-jsonschema/pkg/generator"
)

const testCodexCommit = "0123456789abcdef0123456789abcdef01234567"

func TestMethodBaseName(t *testing.T) {
	if got := methodBaseName("account/login/start"); got != "AccountLoginStart" {
		t.Fatalf("unexpected base name: %s", got)
	}
	if got := methodBaseName("turn/started"); got != "TurnStarted" {
		t.Fatalf("unexpected base name: %s", got)
	}
	if got := methodName(""); got != "Unknown" {
		t.Fatalf("expected Unknown, got %s", got)
	}
}

func TestNormalizeGeneratedHeader(t *testing.T) {
	src := []byte("// Code generated by some tool.\n\npackage foo\n")
	normalized := normalizeGeneratedHeader(src, testCodexCommit)
	if !strings.HasPrefix(string(normalized), generatedHeader(testCodexCommit)) {
		t.Fatalf("expected generated header prefix, got %q", string(normalized))
	}
	if !strings.Contains(string(normalized), "package foo") {
		t.Fatalf("expected package line to remain, got %q", string(normalized))
	}

	unchanged := []byte("package bar\n")
	if got := normalizeGeneratedHeader(unchanged, testCodexCommit); string(got) != string(unchanged) {
		t.Fatalf("expected header to remain unchanged, got %q", string(got))
	}
}

func TestRefName(t *testing.T) {
	if got := refName("#/definitions/Foo"); got != "Foo" {
		t.Fatalf("unexpected ref name: %s", got)
	}
	if got := refName("Bar"); got != "Bar" {
		t.Fatalf("unexpected ref name: %s", got)
	}
}

func TestResolveResponseType(t *testing.T) {
	defs := map[string]struct{}{
		"FooResponse": {},
		"BarResponse": {},
	}
	method := rpcMethod{Method: "foo", ParamsType: "FooParams"}
	resp, err := resolveResponseType(method, defs, nil)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if resp != "FooResponse" {
		t.Fatalf("unexpected response type: %s", resp)
	}

	override := map[string]string{"foo": "OverrideResponse"}
	resp, err = resolveResponseType(method, defs, override)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if resp != "OverrideResponse" {
		t.Fatalf("unexpected override response type: %s", resp)
	}

	_, err = resolveResponseType(rpcMethod{Method: "missing"}, defs, nil)
	if err == nil {
		t.Fatalf("expected error for missing response type")
	}
}

func TestBuildRPCMethods(t *testing.T) {
	defs := map[string]struct{}{
		"FooResponse": {},
	}
	methods := []rpcMethod{{Method: "foo", ParamsType: "FooParams"}}
	out, err := buildRPCMethods(methods, defs, nil)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if out[0].ResponseType != "FooResponse" {
		t.Fatalf("unexpected response type: %s", out[0].ResponseType)
	}
}

func TestLoadMethodsAndNotifications(t *testing.T) {
	dir := t.TempDir()
	methodPath := filepath.Join(dir, "ClientRequest.json")
	payload := oneOfSchema{
		OneOf: []schemaVariant{
			{Properties: map[string]schemaProperty{"method": {Enum: []string{"foo/bar"}}, "params": {Ref: "#/definitions/FooParams"}}},
			{Properties: map[string]schemaProperty{"method": {Enum: []string{"baz"}}, "params": {Type: "null"}}},
		},
	}
	writeJSON(t, methodPath, payload)

	methods, err := loadMethods(methodPath)
	if err != nil {
		t.Fatalf("loadMethods error: %v", err)
	}
	if len(methods) != 2 {
		t.Fatalf("expected 2 methods, got %d", len(methods))
	}
	if methods[0].Method != "baz" || methods[1].Method != "foo/bar" {
		t.Fatalf("unexpected methods: %#v", methods)
	}

	notifyPath := filepath.Join(dir, "ServerNotification.json")
	writeJSON(t, notifyPath, payload)
	notes, err := loadNotifications(notifyPath)
	if err != nil {
		t.Fatalf("loadNotifications error: %v", err)
	}
	if len(notes) != 2 || notes[0].Method != "baz" {
		t.Fatalf("unexpected notifications: %#v", notes)
	}
}

func TestStripAndSanitize(t *testing.T) {
	input := map[string]any{
		"oneOf": []any{map[string]any{"type": "string"}},
		"anyOf": []any{map[string]any{"type": "number"}},
		"nested": map[string]any{
			"oneOf": []any{map[string]any{"type": "object"}},
		},
	}
	stripSubschemas(input)
	if _, ok := input["oneOf"]; ok {
		t.Fatalf("expected oneOf removed")
	}
	if _, ok := input["anyOf"]; ok {
		t.Fatalf("expected anyOf removed")
	}
	nested := input["nested"].(map[string]any)
	if _, ok := nested["oneOf"]; ok {
		t.Fatalf("expected nested oneOf removed")
	}

	dir := t.TempDir()
	path := filepath.Join(dir, "schema.json")
	writeJSON(t, path, input)

	sanitized, cleanup, err := sanitizeSchemaFile(path)
	if err != nil {
		t.Fatalf("sanitizeSchemaFile error: %v", err)
	}
	defer cleanup()

	data, err := os.ReadFile(sanitized)
	if err != nil {
		t.Fatalf("read sanitized file: %v", err)
	}
	if strings.Contains(string(data), "oneOf") || strings.Contains(string(data), "anyOf") {
		t.Fatalf("expected oneOf/anyOf stripped from sanitized file")
	}
}

func TestCollectGeneratedTypes(t *testing.T) {
	sources := map[string][]byte{
		"a.go": []byte("package protocol\n\ntype Foo struct{}\n"),
		"b.go": []byte("package protocol\n\ntype Bar interface{}\n"),
	}
	generated := collectGeneratedTypes(sources)
	if _, ok := generated["Foo"]; !ok {
		t.Fatalf("expected Foo in generated types")
	}
	if _, ok := generated["Bar"]; !ok {
		t.Fatalf("expected Bar in generated types")
	}
}

func TestWriteFallbackTypesAndAliases(t *testing.T) {
	dir := t.TempDir()
	generated := map[string]struct{}{
		"KnownJSON": {},
	}
	fallbacks := []string{"Missing"}

	if err := writeFallbackTypes(dir, fallbacks, generated, testCodexCommit); err != nil {
		t.Fatalf("writeFallbackTypes error: %v", err)
	}
	data, err := os.ReadFile(filepath.Join(dir, "fallback_gen.go"))
	if err != nil {
		t.Fatalf("read fallback file: %v", err)
	}
	if !strings.Contains(string(data), "Source codex commit: "+testCodexCommit) {
		t.Fatalf("expected codex commit header")
	}
	if !strings.Contains(string(data), "type Missing interface{}") {
		t.Fatalf("expected Missing fallback")
	}

	if err := writeProtocolAliases(dir, generated, fallbacks, testCodexCommit); err != nil {
		t.Fatalf("writeProtocolAliases error: %v", err)
	}
	aliasData, err := os.ReadFile(filepath.Join(dir, "aliases_gen.go"))
	if err != nil {
		t.Fatalf("read alias file: %v", err)
	}
	if !strings.Contains(string(aliasData), "type Known = KnownJSON") {
		t.Fatalf("expected alias for Known")
	}
}

func TestRenderHelpers(t *testing.T) {
	methods := []rpcMethod{
		{Method: "foo/bar", ParamsType: "FooParams", ResponseType: "FooResponse"},
	}
	client := string(renderClientRequests(methods, testCodexCommit))
	if !strings.Contains(client, "Source codex commit: "+testCodexCommit) {
		t.Fatalf("expected codex commit header")
	}
	if !strings.Contains(client, "func (c *Client) FooBar") {
		t.Fatalf("expected client method")
	}
	if !strings.Contains(client, "BuildClientRequest") {
		t.Fatalf("expected BuildClientRequest")
	}

	server := string(renderServerRequests(methods, testCodexCommit))
	if !strings.Contains(server, "unsupported server request") {
		t.Fatalf("expected server dispatch")
	}

	notes := string(renderNotifications([]rpcNotification{{Method: "turn/started", ParamsType: "TurnStartedNotification"}}, testCodexCommit))
	if !strings.Contains(notes, "turn/started") {
		t.Fatalf("expected notification method")
	}
}

func TestSchemaTitleAndDefinitions(t *testing.T) {
	dir := t.TempDir()
	path := filepath.Join(dir, "schema.json")
	writeJSON(t, path, map[string]any{
		"title": "MySchema",
		"definitions": map[string]any{
			"Thing": map[string]any{"type": "object"},
		},
	})

	title, err := schemaTitle(path)
	if err != nil {
		t.Fatalf("schemaTitle error: %v", err)
	}
	if title != "MySchema" {
		t.Fatalf("unexpected title: %s", title)
	}

	defs, err := parseDefinitionNames(dir)
	if err != nil {
		t.Fatalf("parseDefinitionNames error: %v", err)
	}
	if _, ok := defs["MySchema"]; !ok {
		t.Fatalf("expected title in defs")
	}
	if _, ok := defs["Thing"]; !ok {
		t.Fatalf("expected definition in defs")
	}
}

func TestFindSchemaFiles(t *testing.T) {
	dir := t.TempDir()
	if err := os.WriteFile(filepath.Join(dir, "a.json"), []byte("{}"), 0o644); err != nil {
		t.Fatalf("write file: %v", err)
	}
	if err := os.WriteFile(filepath.Join(dir, "b.txt"), []byte("x"), 0o644); err != nil {
		t.Fatalf("write file: %v", err)
	}
	files, err := findSchemaFiles(dir)
	if err != nil {
		t.Fatalf("findSchemaFiles error: %v", err)
	}
	if len(files) != 1 || !strings.HasSuffix(files[0], "a.json") {
		t.Fatalf("unexpected files: %#v", files)
	}
}

func TestWriteFileAndExists(t *testing.T) {
	dir := t.TempDir()
	if err := writeFile(dir, "out.txt", []byte("hello")); err != nil {
		t.Fatalf("writeFile error: %v", err)
	}
	if !exists(filepath.Join(dir, "out.txt")) {
		t.Fatalf("expected file to exist")
	}
	if exists(filepath.Join(dir, "missing.txt")) {
		t.Fatalf("expected missing file to be absent")
	}
}

func TestSkipSchemaFiles(t *testing.T) {
	skip := skipSchemaFiles()
	if !skip["JSONRPCMessage.json"] {
		t.Fatalf("expected JSONRPCMessage.json to be skipped")
	}
	if skip["Other.json"] {
		t.Fatalf("unexpected skip for Other.json")
	}
}

func TestRepoRoot(t *testing.T) {
	root, err := repoRoot()
	if err != nil {
		t.Fatalf("repoRoot error: %v", err)
	}
	if !exists(filepath.Join(root, "go.mod")) {
		t.Fatalf("expected go.mod in repo root")
	}
	if !exists(filepath.Join(root, "internal", "codegen", "main.go")) {
		t.Fatalf("expected internal/codegen/main.go in repo root")
	}
}

func TestCodexRepoRootDefault(t *testing.T) {
	base := t.TempDir()
	sdkRoot := filepath.Join(base, "codex-sdk-go")
	codexRoot := filepath.Join(base, "codex")
	if err := os.MkdirAll(filepath.Join(sdkRoot, "internal"), 0o755); err != nil {
		t.Fatalf("mkdir sdk root: %v", err)
	}
	if err := os.MkdirAll(filepath.Join(codexRoot, "codex-rs"), 0o755); err != nil {
		t.Fatalf("mkdir codex root: %v", err)
	}

	got, err := codexRepoRoot(sdkRoot)
	if err != nil {
		t.Fatalf("codexRepoRoot error: %v", err)
	}
	if got != codexRoot {
		t.Fatalf("unexpected codex root: got %q want %q", got, codexRoot)
	}
}

func TestCodexRepoRootFromEnv(t *testing.T) {
	base := t.TempDir()
	sdkRoot := filepath.Join(base, "codex-sdk-go")
	custom := filepath.Join("deps", "codex-source")
	expected := filepath.Join(sdkRoot, custom)
	if err := os.MkdirAll(filepath.Join(expected, "codex-rs"), 0o755); err != nil {
		t.Fatalf("mkdir codex root: %v", err)
	}

	t.Setenv(codexRepoRootEnv, custom)
	got, err := codexRepoRoot(sdkRoot)
	if err != nil {
		t.Fatalf("codexRepoRoot error: %v", err)
	}
	if got != expected {
		t.Fatalf("unexpected codex root: got %q want %q", got, expected)
	}
}

func TestCodexCommitHashError(t *testing.T) {
	_, err := codexCommitHash(t.TempDir())
	if err == nil {
		t.Fatalf("expected codexCommitHash error")
	}
}

func TestSafeDoFile(t *testing.T) {
	dir := t.TempDir()
	schema := map[string]any{
		"title": "Foo",
		"type":  "object",
		"properties": map[string]any{
			"name": map[string]any{"type": "string"},
		},
	}
	path := filepath.Join(dir, "Foo.json")
	writeJSON(t, path, schema)

	gen, err := generator.New(generator.Config{
		DefaultPackageName: "protocol",
		DefaultOutputName:  "types_gen.go",
		OnlyModels:         true,
	})
	if err != nil {
		t.Fatalf("generator.New error: %v", err)
	}
	if err := safeDoFile(gen, path); err != nil {
		t.Fatalf("safeDoFile error: %v", err)
	}
	sources, err := gen.Sources()
	if err != nil {
		t.Fatalf("sources error: %v", err)
	}
	if len(sources) == 0 {
		t.Fatalf("expected generated sources")
	}
}

func TestParamsType(t *testing.T) {
	if got := paramsType(""); got != "struct{}" {
		t.Fatalf("unexpected params type: %s", got)
	}
	if got := paramsType("Foo"); got != "protocol.Foo" {
		t.Fatalf("unexpected params type: %s", got)
	}
}

func TestGenerateProtocolTypes(t *testing.T) {
	root := t.TempDir()
	schemaDir := filepath.Join(root, "schemas")
	if err := os.MkdirAll(schemaDir, 0o755); err != nil {
		t.Fatalf("mkdir: %v", err)
	}
	writeJSON(t, filepath.Join(schemaDir, "Foo.json"), map[string]any{
		"title": "Foo",
		"type":  "object",
		"properties": map[string]any{
			"name": map[string]any{"type": "string"},
		},
	})

	if err := generateProtocolTypes(schemaDir, root, testCodexCommit); err != nil {
		t.Fatalf("generateProtocolTypes error: %v", err)
	}
	if !exists(filepath.Join(root, "protocol", "types_gen.go")) {
		t.Fatalf("expected types_gen.go output")
	}
	typesData, err := os.ReadFile(filepath.Join(root, "protocol", "types_gen.go"))
	if err != nil {
		t.Fatalf("read generated protocol file: %v", err)
	}
	if !strings.Contains(string(typesData), "Source codex commit: "+testCodexCommit) {
		t.Fatalf("expected codex commit header in protocol output")
	}
}

func TestGenerateRPCStubs(t *testing.T) {
	root := t.TempDir()
	schemaDir := filepath.Join(root, "schemas")
	if err := os.MkdirAll(schemaDir, 0o755); err != nil {
		t.Fatalf("mkdir: %v", err)
	}

	writeJSON(t, filepath.Join(schemaDir, "PingResponse.json"), map[string]any{
		"title": "PingResponse",
		"type":  "object",
	})
	writeJSON(t, filepath.Join(schemaDir, "ClientRequest.json"), map[string]any{
		"oneOf": []map[string]any{
			{
				"properties": map[string]any{
					"method": map[string]any{"enum": []string{"ping"}},
					"params": map[string]any{"type": "null"},
				},
			},
		},
	})
	writeJSON(t, filepath.Join(schemaDir, "ServerRequest.json"), map[string]any{
		"oneOf": []map[string]any{
			{
				"properties": map[string]any{
					"method": map[string]any{"enum": []string{"ping"}},
					"params": map[string]any{"type": "null"},
				},
			},
		},
	})
	writeJSON(t, filepath.Join(schemaDir, "ServerNotification.json"), map[string]any{
		"oneOf": []map[string]any{
			{
				"properties": map[string]any{
					"method": map[string]any{"enum": []string{"pong"}},
					"params": map[string]any{"type": "null"},
				},
			},
		},
	})

	if err := generateRPCStubs(schemaDir, root, testCodexCommit); err != nil {
		t.Fatalf("generateRPCStubs error: %v", err)
	}
	if !exists(filepath.Join(root, "rpc", "client_requests_gen.go")) {
		t.Fatalf("expected client_requests_gen.go output")
	}
	if !exists(filepath.Join(root, "rpc", "notifications_gen.go")) {
		t.Fatalf("expected notifications_gen.go output")
	}
	rpcData, err := os.ReadFile(filepath.Join(root, "rpc", "client_requests_gen.go"))
	if err != nil {
		t.Fatalf("read generated rpc file: %v", err)
	}
	if !strings.Contains(string(rpcData), "Source codex commit: "+testCodexCommit) {
		t.Fatalf("expected codex commit header in rpc output")
	}
}

func TestExportSchemasError(t *testing.T) {
	dir := t.TempDir()
	if err := exportSchemas(dir, filepath.Join(dir, "out")); err == nil {
		t.Fatalf("expected exportSchemas error")
	}
}

func writeJSON(t *testing.T, path string, payload any) {
	t.Helper()
	data, err := json.Marshal(payload)
	if err != nil {
		t.Fatalf("marshal error: %v", err)
	}
	if err := os.WriteFile(path, data, 0o644); err != nil {
		t.Fatalf("write file: %v", err)
	}
}
